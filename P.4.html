<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Análisis de Componentes Principales</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="P.4_files/libs/clipboard/clipboard.min.js"></script>
<script src="P.4_files/libs/quarto-html/quarto.js"></script>
<script src="P.4_files/libs/quarto-html/popper.min.js"></script>
<script src="P.4_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="P.4_files/libs/quarto-html/anchor.min.js"></script>
<link href="P.4_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="P.4_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="P.4_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="P.4_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="P.4_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introducción" id="toc-introducción" class="nav-link active" data-scroll-target="#introducción"><span class="header-section-number">1</span> Introducción</a>
  <ul class="collapse">
  <li><a href="#definición" id="toc-definición" class="nav-link" data-scroll-target="#definición"><span class="header-section-number">1.1</span> Definición:</a></li>
  <li><a href="#descripción-general-del-método" id="toc-descripción-general-del-método" class="nav-link" data-scroll-target="#descripción-general-del-método"><span class="header-section-number">1.2</span> Descripción general del método</a></li>
  <li><a href="#supuestos-del-método" id="toc-supuestos-del-método" class="nav-link" data-scroll-target="#supuestos-del-método"><span class="header-section-number">1.3</span> Supuestos del método</a></li>
  </ul></li>
  <li><a href="#reconstrucción-exacta-de-una-matriz-de-datos-usando-valores-y-vectores-propios" id="toc-reconstrucción-exacta-de-una-matriz-de-datos-usando-valores-y-vectores-propios" class="nav-link" data-scroll-target="#reconstrucción-exacta-de-una-matriz-de-datos-usando-valores-y-vectores-propios"><span class="header-section-number">2</span> Reconstrucción Exacta de una Matriz de Datos usando Valores y Vectores Propios</a>
  <ul class="collapse">
  <li><a href="#la-descomposición-en-valores-singulares-dvs" id="toc-la-descomposición-en-valores-singulares-dvs" class="nav-link" data-scroll-target="#la-descomposición-en-valores-singulares-dvs"><span class="header-section-number">2.1</span> La Descomposición en Valores Singulares (DVS)</a></li>
  <li><a href="#interpretación-y-utilidad-en-acp" id="toc-interpretación-y-utilidad-en-acp" class="nav-link" data-scroll-target="#interpretación-y-utilidad-en-acp"><span class="header-section-number">2.2</span> Interpretación y utilidad en ACP</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Análisis de Componentes Principales</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introducción" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introducción</h1>
<p>En la investigación aplicada, especialmente en ciencias sociales, biología, economía e ingeniería es común trabajar con conjuntos de datos de alta dimensionalidad. Aunque un mayor número de variables puede aportar información valiosa, su análisis simultáneo presenta dificultades como el aumento de parámetros a estimar, el riesgo de multicolinealidad y la complejidad para interpretar la estructura subyacente de los datos. Esto hace necesario emplear métodos que resuman la información esencial sin perder las características relevantes del conjunto original.</p>
<p>El Análisis de Componentes Principales (ACP) es una técnica multivariante diseñada precisamente para reducir la dimensionalidad. Transforma las variables originales en un nuevo conjunto menor de variables no correlacionadas, denominadas componentes principales. Estas componentes son combinaciones lineales de las variables originales, construidas de modo que capturen la máxima varianza posible, concentrando así la mayor cantidad de información.</p>
<section id="definición" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="definición"><span class="header-section-number">1.1</span> Definición:</h2>
<p>El Análisis de Componentes Principales (ACP) es una técnica estadística multivariante cuyo objetivo es transformar un conjunto de variables originales <span class="math inline">\(X_1, X_2, \dots, X_p\)</span> en un nuevo conjunto de variables no correlacionadas llamadas <strong>componentes principales</strong>. Estas nuevas variables son combinaciones lineales de las variables originales y se construyen de forma que capturen la máxima varianza posible, es decir, la mayor cantidad de información contenida en los datos.</p>
<p>Formalmente, el <span class="math inline">\(k\)</span>-ésimo componente principal se define como:</p>
<p><span class="math display">\[
Y_k = a_{1k}X_1 + a_{2k}X_2 + \cdots + a_{pk}X_p,
\]</span></p>
<p>donde el vector</p>
<p><span class="math display">\[
\mathbf{a}_k = (a_{1k}, a_{2k}, \dots, a_{pk})'
\]</span></p>
<p>es el <strong>autovector</strong> correspondiente al <span class="math inline">\(k\)</span>-ésimo <strong>autovalor</strong> <span class="math inline">\(\lambda_k\)</span> de la matriz de covarianzas (o correlaciones) del conjunto de variables originales.</p>
<p>Los autovalores cumplen:</p>
<p><span class="math display">\[
\lambda_1 \ge \lambda_2 \ge \cdots \ge \lambda_p \ge 0,
\]</span></p>
<p>y cada <span class="math inline">\(\lambda_k\)</span> representa la <strong>varianza explicada</strong> por el componente principal <span class="math inline">\(Y_k\)</span>.<br>
El primer componente principal captura la mayor varianza posible; el segundo captura la mayor varianza restante bajo la condición de ser <strong>ortogonal</strong> al primero, y así sucesivamente.</p>
</section>
<section id="descripción-general-del-método" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="descripción-general-del-método"><span class="header-section-number">1.2</span> Descripción general del método</h2>
<p>Existen dos enfoques principales para comprender el método del Análisis de Componentes Principales (ACP). El primero, tradicionalmente utilizado en estadística, consiste en construir los componentes en las direcciones donde la matriz de datos <span class="math inline">\(X\)</span> presenta la <strong>máxima varianza</strong>. Bajo este enfoque, el primer componente principal es la combinación lineal de las variables que captura la mayor variabilidad posible; el segundo componente captura la mayor variabilidad restante bajo la condición de ser ortogonal al primero, y así sucesivamente. Para ello se emplean los autovalores y autovectores de la matriz de covarianzas o correlaciones, lo que garantiza que los componentes sean no correlacionados y estén ordenados según la varianza explicada.</p>
<p>El segundo enfoque proviene del aprendizaje estadístico moderno, donde el ACP se interpreta como un problema de optimización que busca la mejor aproximación de la matriz de datos con menor dimensión. Esta aproximación se obtiene mediante la descomposición en valores singulares (SVD), que produce las mismas direcciones de variabilidad máxima que el enfoque clásico.</p>
<p>Ambos enfoques producen la misma solución: los componentes principales corresponden a las direcciones de máxima varianza de <span class="math inline">\(X\)</span> y simultáneamente a las direcciones que generan la mejor aproximación de rango reducido de la matriz de datos. Esta equivalencia explica la solidez del ACP y su importancia tanto en la estadística clásica como en el aprendizaje automático.</p>
</section>
<section id="supuestos-del-método" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="supuestos-del-método"><span class="header-section-number">1.3</span> Supuestos del método</h2>
<p>El Análisis de Componentes Principales (ACP) se basa en varios supuestos que garantizan la validez de su interpretación y de sus resultados:</p>
<ol type="1">
<li><p><strong>Relación lineal entre variables:</strong><br>
El ACP asume que las relaciones entre las variables pueden describirse adecuadamente mediante combinaciones lineales. No es adecuado para capturar relaciones no lineales.</p></li>
<li><p><strong>Escalas comparables entre variables:</strong><br>
Dado que la varianza es sensible a la escala de medición, las variables deben estar estandarizadas cuando poseen unidades o magnitudes muy diferentes.</p></li>
<li><p><strong>Varianza significativa en las variables:</strong><br>
Las variables deben presentar variabilidad suficiente; variables casi constantes no aportan información y distorsionan los componentes.</p></li>
<li><p><strong>Número adecuado de observaciones:</strong><br>
Se recomienda contar con un número de observaciones considerablemente mayor que el número de variables para obtener estimaciones estables de la matriz de covarianzas o correlaciones.</p></li>
<li><p><strong>Ausencia de multicolinealidad perfecta:</strong><br>
Aunque el ACP maneja bien la colinealidad, no puede aplicarse cuando algunas variables son combinaciones lineales exactas de otras, pues la matriz de covarianzas sería singular.</p></li>
<li><p><strong>Normalidad multivariada (deseable pero no estrictamente necesaria):</strong><br>
El ACP no requiere que las variables sigan una distribución normal multivariada para ser calculado; sin embargo, este supuesto es útil cuando se desea realizar inferencias estadísticas o interpretar los componentes dentro de un modelo probabilístico.</p></li>
</ol>
<p>En conjunto, estos supuestos aseguran que el ACP proporcione componentes interpretables y representativos de la estructura interna de los datos. El cumplimiento de estos principios contribuye a mejorar la estabilidad y la calidad de los resultados obtenidos.</p>
</section>
</section>
<section id="reconstrucción-exacta-de-una-matriz-de-datos-usando-valores-y-vectores-propios" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Reconstrucción Exacta de una Matriz de Datos usando Valores y Vectores Propios</h1>
<p>En el análisis multivariado, y en particular en métodos como el Análisis de Componentes Principales (ACP), es posible reconstruir exactamente una matriz de datos utilizando sus valores y vectores propios gracias a la Descomposición en Valores Singulares (DVS).</p>
<p>Este procedimiento descompone una matriz en el producto de tres matrices con características específicas, lo que no solo facilita su interpretación geométrica, sino que también resulta muy útil para realizar reducción de dimensionalidad.</p>
<section id="la-descomposición-en-valores-singulares-dvs" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="la-descomposición-en-valores-singulares-dvs"><span class="header-section-number">2.1</span> La Descomposición en Valores Singulares (DVS)</h2>
<p>La DVS muestra que cualquier matriz <span class="math inline">\(C\)</span> de tamaño <span class="math inline">\(n \times p\)</span> y rango <span class="math inline">\(r\)</span> puede factorizarse de la siguiente forma:</p>
<p><span class="math display">\[
C = V L U'
\]</span></p>
<p>Donde:</p>
<ul>
<li><span class="math inline">\(L\)</span>: matriz diagonal <span class="math inline">\(r \times r\)</span> que contiene los <strong>valores propios</strong> de <span class="math inline">\(C\)</span>, es decir, <span class="math inline">\(\sqrt{\lambda_j}\)</span>, donde <span class="math inline">\(\lambda_j\)</span> es el <span class="math inline">\(j\)</span>-ésimo valor propio de <span class="math inline">\(C'C\)</span></li>
<li><span class="math inline">\(U\)</span>: matriz <span class="math inline">\(p \times r\)</span> cuyas columnas son los <strong>vectores propios de</strong> <span class="math inline">\(C'C\)</span></li>
<li><span class="math inline">\(V\)</span>: matriz <span class="math inline">\(n \times r\)</span> cuyas columnas son los <strong>vectores propios de</strong> <span class="math inline">\(CC'\)</span></li>
<li>Ambas matrices <span class="math inline">\(U\)</span> y <span class="math inline">\(V\)</span> son <strong>ortonormales</strong>: <span class="math inline">\(U'U = V'V = I_r\)</span></li>
</ul>
<p>Luego, cuando aplicamos la DVS a la matriz <span class="math inline">\(X\)</span> centrada y estandarizada, obtenemos que:</p>
<p><span class="math display">\[
X = V L U'
\]</span></p>
<p>Donde:</p>
<ul>
<li><span class="math inline">\(L\)</span> contiene <span class="math inline">\(\sqrt{\lambda_\alpha}\)</span>, con <span class="math inline">\(\lambda_\alpha\)</span> siendo los valores propios de <span class="math inline">\(X'X\)</span></li>
<li>Las columnas de <span class="math inline">\(U\)</span> son los vectores propios de <span class="math inline">\(X'X\)</span></li>
<li>Las columnas de <span class="math inline">\(V\)</span> son los vectores propios de <span class="math inline">\(XX'\)</span></li>
</ul>
<p>Ahora bien, Se puede escribir X en su forma expandida</p>
<p><span class="math display">\[
X \;=\; [\,v_1\; v_2\; \dots\; v_p\,]
\;
\begin{bmatrix}
\sqrt{\lambda_1} &amp; 0 &amp; \cdots &amp; 0\\[4pt]
0 &amp; \sqrt{\lambda_2} &amp; \cdots &amp; 0\\[4pt]
\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\[4pt]
0 &amp; 0 &amp; \cdots &amp; \sqrt{\lambda_p}
\end{bmatrix}
\;
\begin{bmatrix}
u_1'\\[4pt]
u_2'\\[4pt]
\vdots\\[4pt]
u_p'
\end{bmatrix}
\]</span></p>
<p>Luego, al multiplicar ( V ) por ( L ) tenemos que:</p>
<p><span class="math display">\[ VL =  [ \sqrt{\lambda_1} v_1, \sqrt{\lambda_2} v_2, \dots, \sqrt{\lambda_p} v_p ] \]</span></p>
<p>y al multiplicar por ( U’ ):</p>
<p><span class="math display">\[
X \;=\; \big[\,\sqrt{\lambda_1}\,v_1,\; \sqrt{\lambda_2}\,v_2,\; \dots,\; \sqrt{\lambda_p}\,v_p\,\big]
\begin{bmatrix}
u_1'\\[4pt]
u_2'\\[4pt]
\vdots\\[4pt]
u_p'
\end{bmatrix}
\]</span> <span class="math display">\[
X \;=\; \sqrt{\lambda_1}\,v_1 u_1' \;+\; \sqrt{\lambda_2}\,v_2 u_2' \;+\; \cdots \;+\; \sqrt{\lambda_p}\,v_p u_p'
\]</span></p>
<p><span class="math display">\[
X\;=\; \sum_{\alpha=1}^{p} \sqrt{\lambda_\alpha}\, v_\alpha u_\alpha'
\]</span> Esto nos muestra que toda la información de la matriz original está contenida en sus valores y vectores propios.</p>
<p>Por otro lado, un resultado clave que surge de la DVS es la <strong>equivalencia entre los valores propios de</strong> (X’X) <strong>y</strong> (XX’). Ambos comparten los mismos valores propios no nulos (<span class="math inline">\(\lambda_{\alpha})\)</span>. Esto es:</p>
<ul>
<li><p>Si (<span class="math inline">\(u_{\alpha}\)</span>) es un vector propio de (X’X), entonces <span class="math inline">\(\frac{1}{\sqrt{\lambda_\alpha}}\,Xu_\alpha\)</span> es un vector propio de (XX’).</p></li>
<li><p>Análogamente, si (<span class="math inline">\(v_{\alpha}\)</span>) es un vector propio de (XX’), entonces<br>
<span class="math inline">\(\frac{1}{\sqrt{\lambda_\alpha}}\,X'v_\alpha\)</span> es un vector propio de (X’X).</p></li>
</ul>
<p>Esto implica que <strong>solo es necesario calcular los valores y vectores propios de una de estas matrices</strong> para obtener también los de la otra.</p>
</section>
<section id="interpretación-y-utilidad-en-acp" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="interpretación-y-utilidad-en-acp"><span class="header-section-number">2.2</span> Interpretación y utilidad en ACP</h2>
<p>Asi, la factorizacion <span class="math inline">\(X=VLU´\)</span> muetra una transformacion diferente de los datos:</p>
<ul>
<li><p><strong>Las Componentes Principales (Scores de los Individuos):</strong><br>
La matriz $ Z = V L $ contiene las <strong>coordenadas de los individuos</strong>,es decir, cada columna de Z representa la proyección de todas las observaciones sobre la <span class="math inline">\(\alpha\)</span>-ésima componente. Esto muestra cómo se ubican mis muestras en el nuevo espacio de características reducido</p></li>
<li><p><strong>Las Cargas Factoriales (Contribuciones de las Variables):</strong><br>
La matriz $ U $ (o, en su versión escalada, $ U $) reúne las cargas factoriales, que muestran el peso y la dirección que tiene cada variable original en la construcción de las componentes principales. Cuando una carga es alta en valor absoluto, significa que esa variable tiene una influencia importante sobre la componente correspondiente. Es decir, la matriz <span class="math inline">\(U\)</span> nos muestra qué variables originales son las que realmente están impulsando cada componente</p></li>
</ul>
<p>En general, La reconstrucción exacta de la matriz <span class="math inline">\(X\)</span> a través de la DVS no solo es un resultado teórico interesante, sino que también constituye el fundamento computacional del ACP. Gracias a este enfoque es posible reducir la dimensionalidad sin perder la estructura esencial de los datos, facilitar la visualización de las relaciones entre individuos y variables, y comprender mejor la geometría que hay detrás del conjunto de datos.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>